<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Guardian: Project Neutrino</title>
    <!-- Favicon (çµµæ–‡å­—: UFO) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ›¸</text></svg>">
    <!-- Tailwind CSS (ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°ç”¨) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            background-color: #050505;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
            touch-action: none; /* ãƒ¢ãƒã‚¤ãƒ«ã§ã®ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç­‰ã‚’é˜²æ­¢ */
            font-family: 'Orbitron', sans-serif;
            color: white;
            /* å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ã‚¨ãƒªã‚¢ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã‚«ãƒ¼ã‚½ãƒ« */
            cursor: crosshair;
            user-select: none; /* ãƒ†ã‚­ã‚¹ãƒˆé¸æŠé˜²æ­¢ */
            -webkit-user-select: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #uiLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã¸ã®ã‚¯ãƒªãƒƒã‚¯ã‚’é€éã•ã›ã‚‹ */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-text {
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        /* è­¦å‘Šè¡¨ç¤ºç”¨ */
        #warningLayer {
            position: absolute;
            top: 30%;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 15;
            pointer-events: none;
            display: none;
        }
        .warning-text {
            font-size: 3rem;
            color: #ff0055;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0055;
            animation: blink 0.2s infinite alternate;
        }
        @keyframes blink {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0.5; transform: scale(1.1); }
        }

        /* HUDç™ºå…‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes hudFlashAnim {
            0% { transform: scale(1); text-shadow: 0 0 0 transparent; }
            20% { transform: scale(2.0); color: #ffffff; } /* ä¸€ç¬ç™½ãå¤§ãã */
            100% { transform: scale(1); }
        }

        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆç”¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (ãƒœãƒ ç™ºå‹•æ™‚ãªã©ã«ä½¿ç”¨) */
        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ãƒœãƒ ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ç”¨ */
        #flashLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ (ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼) */
        #menuLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            z-index: 12; /* UIã‚ˆã‚Šä¸Š */
            pointer-events: none; /* ã‚¨ãƒªã‚¢è‡ªä½“ã¯é€é */
            display: none; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆéè¡¨ç¤º */
        }

        /* ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒªã‚¢ */
        #joystickZone {
            position: absolute;
            bottom: 20px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto; /* æ“ä½œå¯èƒ½ã« */
            touch-action: none;
        }

        /* ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ã¤ã¾ã¿ */
        #joystickKnob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        /* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
        #actionZone {
            position: absolute;
            bottom: 20px;
            right: 30px;
            display: flex;
            gap: 20px;
            align-items: flex-end;
            pointer-events: auto;
        }

        .action-btn {
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            touch-action: none;
            user-select: none;
            transition: transform 0.1s, background 0.1s;
        }
        .action-btn:active {
            transform: scale(0.95);
        }

        #shootBtn {
            width: 90px;
            height: 90px;
            background: rgba(255, 0, 85, 0.3);
            border: 2px solid #ff0055;
            color: #ff0055;
            font-size: 1.2rem;
        }
        #shootBtn.active {
            background: rgba(255, 0, 85, 0.8);
            color: white;
            box-shadow: 0 0 20px #ff0055;
        }

        #mobileBombBtn {
            width: 60px;
            height: 60px;
            background: rgba(255, 170, 0, 0.3);
            border: 2px solid #ffaa00;
            color: #ffaa00;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        #mobileBombBtn:active {
            background: rgba(255, 170, 0, 0.8);
            color: white;
            box-shadow: 0 0 20px #ffaa00;
        }

        /* ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ« */
        #storyModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
            background: rgba(0, 0, 0, 0.95);
            display: none; /* åˆæœŸã¯éè¡¨ç¤º */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }

        /* ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–è¦ç´ ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ‰åŠ¹åŒ– */
        .interactive {
            pointer-events: auto;
            cursor: pointer;
        }

        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 10px #00ffff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        /* ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ */
        input[type=checkbox] {
            accent-color: #00ffff;
            transform: scale(1.5);
            cursor: pointer;
        }

        .neon-btn {
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 12px 40px;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.2s;
            border-radius: 4px;
        }
        .neon-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        /* è¨­å®šãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ */
        .toggle-btn {
            color: #888;
            font-size: 0.9rem;
            cursor: pointer;
            border-bottom: 1px dotted #888;
            margin-bottom: 1rem;
            transition: color 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .toggle-btn:hover {
            color: #00ffff;
            border-bottom-color: #00ffff;
        }
        
        .reset-btn {
            font-size: 0.8rem;
            color: #ffaa00;
            border: 1px solid #ffaa00;
            padding: 4px 12px;
            border-radius: 4px;
            margin-top: 10px;
            transition: all 0.2s;
        }
        .reset-btn:hover {
            background: #ffaa00;
            color: black;
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºç”¨ */
        #statusDisplay {
            font-size: 0.8rem;
            color: #ccc;
            margin-top: 0.5rem;
            line-height: 1.4;
            text-align: right;
        }
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®æ•°å€¤éƒ¨åˆ† */
        .stat-val {
            display: inline-block;
            transition: all 0.1s;
        }
    </style>
</head>
<body oncontextmenu="return false;"> <!-- å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç„¡åŠ¹åŒ– -->

    <!-- ã‚²ãƒ¼ãƒ æç”»ã‚¨ãƒªã‚¢ -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- ãƒœãƒ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ -->
    <div id="flashLayer"></div>
    
    <!-- è­¦å‘Šè¡¨ç¤º -->
    <div id="warningLayer">
        <div id="warningTitle" class="warning-text">WARNING</div>
        <div id="warningSubtitle" class="text-white text-xl tracking-widest mt-2">GIANT ENEMY DETECTED</div>
    </div>

    <!-- ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (ã‚¹ãƒãƒ›ã®ã¿è¡¨ç¤º) -->
    <div id="mobileControls">
        <!-- å·¦: ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ -->
        <div id="joystickZone">
            <div id="joystickKnob"></div>
        </div>
        <!-- å³: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ -->
        <div id="actionZone">
            <div id="mobileBombBtn" class="action-btn">BOMB</div>
            <div id="shootBtn" class="action-btn">SHOOT</div>
        </div>
    </div>

    <!-- ãƒ—ãƒ¬ã‚¤ä¸­ã®HUD (ã‚¹ã‚³ã‚¢ãªã©) -->
    <div id="uiLayer">
        <div class="flex justify-between items-start w-full max-w-5xl mx-auto">
            <!-- å·¦å´: ã‚¹ã‚³ã‚¢ & ãƒœãƒ  -->
            <div class="hud-text text-xl md:text-2xl w-1/3">
                SCORE: <span id="scoreDisplay">0</span>
                <div class="text-sm text-yellow-400 mt-1">BOMB: <span id="bombDisplay" class="stat-val text-white">0</span> <span id="bombKeyInfo">(Right Click)</span></div>
            </div>
            
            <!-- ä¸­å¤®: æ™‚é–“ -->
            <div class="hud-text text-2xl md:text-3xl text-yellow-400 w-1/3 text-center font-bold">
                <span id="timeDisplay">10:00</span>
            </div>
            
            <!-- å³å´: HP & Heat -->
            <div class="w-1/3 text-right">
                <div class="hud-text text-xl md:text-2xl text-red-400">
                    HP: <span id="hpDisplay" class="stat-val">100</span>%
                </div>
                <div id="statusDisplay">
                    ATK: <span id="statAtk" class="stat-val text-white">10</span> | SPD: <span id="statSpd" class="stat-val text-white">12</span> | SHOT: <span id="statShot" class="stat-val text-white">1</span>
                </div>
                <div class="flex flex-col items-end mt-1">
                    <div class="w-32 md:w-48 bg-gray-800 h-2 border border-gray-600 relative overflow-hidden">
                        <div id="heatBar" class="h-full bg-orange-500 w-0 transition-all duration-75"></div>
                    </div>
                    <div class="text-xs text-orange-400 mt-1" id="heatLabel">HEAT</div>
                </div>
            </div>
        </div>
        <!-- æ“ä½œã‚¬ã‚¤ãƒ‰ -->
        <div id="pcGuide" class="text-center text-gray-500 text-sm mb-4 opacity-50 hidden">
            MOUSE to Move & Aim / CLICK to Shoot / R-CLICK to Bomb
        </div>
        <div id="mobileGuide" class="text-center text-gray-500 text-sm mb-4 opacity-50 hidden">
            L-STICK to Move / R-BUTTON to Shoot / S-BUTTON to Bomb
        </div>
    </div>

    <!-- ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="storyModal" class="interactive">
        <div class="max-w-2xl text-center">
            <h2 class="text-3xl font-bold text-cyan-400 mb-6 border-b border-cyan-800 pb-4">PROJECT: NEUTRINO</h2>
            
            <p class="text-gray-300 mb-6 leading-relaxed text-left text-sm md:text-base">
                è¥¿æš¦204Xå¹´ã€‚ã‚«ãƒŸã‚ªã‚«ãƒ³ãƒ‡å‘¨è¾ºã§è¦³æ¸¬ã•ã‚ŒãŸç•°å¸¸ãªãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒãƒ»ãƒ•ãƒ©ãƒƒã‚¯ã‚¹ã¯ã€æ™‚ç©ºæ§‹é€ ã®ã€ŒçœŸç©ºå´©å£Šã€ã®å‰è§¦ã‚Œã ã£ãŸã€‚<br>
                é«˜æ¬¡å…ƒå®‡å®™ã‹ã‚‰ã®ä¾µç•¥è€…<span class="text-red-400">ã€Œã‚¿ã‚­ã‚ªãƒ³ãƒ»ã‚¹ãƒ¯ãƒ¼ãƒ ã€</span>ã«å¯¾ã—ã€äººé¡ã¯ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒæŒ¯å‹•ã‚’åˆ©ç”¨ã—ãŸå¯¾æ¶ˆæ»…ã‚¨ãƒ³ã‚¸ãƒ³æ­è¼‰æ©Ÿ<span class="text-cyan-400 font-bold">ã€Œãƒã‚ªãƒ³ãƒ»ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³ã€</span>ã‚’æŠ•å…¥ã™ã‚‹ã€‚
            </p>
            
            <p class="text-gray-300 mb-6 leading-relaxed text-left text-sm md:text-base">
                æ•µã‚’æ’ƒç ´ã—ãŸéš›ã«ç”Ÿã˜ã‚‹<span class="text-white font-bold">ã€Œé‡å­ã‚³ã‚¢ã€</span>ã¯ã€<span class="text-yellow-400 font-bold">ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒæŒ¯å‹•</span>ã«ã‚ˆã‚Šãã®ãƒ•ãƒ¬ãƒ¼ãƒãƒ¼ï¼ˆæ€§è³ªï¼‰ã‚’çµ¶ãˆãšå¤‰åŒ–ã•ã›ã¦ã„ã‚‹ã€‚
                ãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã¯ç¬æ™‚ã«ãã®çŠ¶æ…‹ã‚’è¦‹æ¥µã‚ã€æ©Ÿä½“å‡ºåŠ›ã‚’æœ€é©åŒ–ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚
            </p>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 text-sm">
                <div class="border border-red-500 p-3 rounded bg-red-900 bg-opacity-20">
                    <div class="text-red-400 font-bold text-lg mb-1">é›»å­ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒ</div>
                    <div class="text-red-300">Î½e (POWER)</div>
                    <div class="text-gray-400 mt-2 text-xs">è·é›»ã‚«ãƒ¬ãƒ³ãƒˆç›¸äº’ä½œç”¨ã‚’å¢—å¹…ã€‚<br>æ”»æ’ƒç¯„å›²ã¨å¨åŠ›ã‚’å¼·åŒ–ã€‚</div>
                </div>
                <div class="border border-cyan-500 p-3 rounded bg-cyan-900 bg-opacity-20">
                    <div class="text-cyan-400 font-bold text-lg mb-1">ãƒŸãƒ¥ãƒ¼ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒ</div>
                    <div class="text-cyan-300">Î½Î¼ (SPEED)</div>
                    <div class="text-gray-400 mt-2 text-xs">è³ªé‡çŠ¶æ…‹ã®å¤‰ç•°ã‚’åˆ©ç”¨ã€‚<br>å¼¾é€Ÿï¼†å†·å´åŠ¹ç‡å‘ä¸Šã€‚<br>ç™ºç†±é‡æ¸›å°‘ã€‚</div>
                </div>
                <div class="border border-green-500 p-3 rounded bg-green-900 bg-opacity-20">
                    <div class="text-green-400 font-bold text-lg mb-1">ã‚¿ã‚¦ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒªãƒ</div>
                    <div class="text-green-300">Î½Ï„ (HEAL)</div>
                    <div class="text-gray-400 mt-2 text-xs">é‡ã„ä¸–ä»£ã¸ã®å´©å£Šç†±ã‚’è»¢ç”¨ã€‚<br>æ©Ÿä½“ä¿®å¾©ï¼†å¼·åˆ¶å†·å´ã€‚HPæœ€å¤§æ™‚ä¸Šé™çªç ´ã€‚</div>
                </div>
            </div>

            <p class="text-white mb-8 font-bold text-sm md:text-base">
                10åˆ†å¾Œã«äºˆæ¸¬ã•ã‚Œã‚‹ã€Œã‚ªãƒ¡ã‚¬å´©å£Šã€ã‚’é˜»æ­¢ã—ã€å®‡å®™ã®å¯¾ç§°æ€§ã‚’å–ã‚Šæˆ»ã›ã€‚
            </p>

            <button id="closeStoryBtn" class="neon-btn text-sm py-2 px-8">INITIALIZE SYSTEM</button>
        </div>
    </div>

    <!-- ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ (è¨­å®šãƒ»ã‚¹ã‚¿ãƒ¼ãƒˆ) -->
    <div id="menuLayer" class="interactive">
        <h1 class="text-4xl md:text-6xl font-bold mb-2 text-center text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600" style="text-shadow: 0 0 20px rgba(0,255,255,0.5);">
            NEON GUARDIAN
            <span class="block text-xl md:text-3xl text-cyan-200 mt-2 tracking-widest font-light" style="text-shadow: none;">PROJECT: NEUTRINO</span>
        </h1>
        
        <div class="mb-10"></div> <!-- ã‚¹ãƒšãƒ¼ã‚µãƒ¼ -->
        
        <!-- Story & Settings ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ -->
        <div class="flex flex-col items-center gap-4 mb-8 w-full max-w-xs">
            <div id="storyToggle" class="toggle-btn text-cyan-400 border-cyan-400 w-full text-center py-2 border rounded">ğŸ“– ARCHIVE / STORY</div>
            <div id="settingsToggle" class="toggle-btn w-full text-center py-2 border border-gray-600 rounded">âš™ SYSTEM PARAMETERS â–¼</div>
        </div>

        <!-- æŠ˜ã‚Šç•³ã¿å¼ã‚²ãƒ¼ãƒ è¨­å®š GUI -->
        <div id="settingsPanel" class="hidden bg-gray-900 border border-gray-700 p-6 rounded-lg shadow-2xl mb-8 w-11/12 max-w-md interactive transition-all duration-300 max-h-96 overflow-y-auto">
            <h2 class="text-xl text-cyan-400 mb-4 border-b border-gray-700 pb-2">SYSTEM PARAMETERS</h2>
            
            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between items-center">
                    <span>AUTO AIM (ã‚ªãƒ¼ãƒˆã‚¨ã‚¤ãƒ )</span>
                    <input type="checkbox" id="autoAimToggle">
                </label>
                <p class="text-gray-500 text-xs mt-1">PC/Mobile Default ON</p>
            </div>

            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between">
                    <span>ENEMY SPAWN RATE (åˆæœŸå‡ºç¾ç‡)</span>
                    <span id="spawnVal" class="text-white">Normal</span>
                </label>
                <input type="range" id="spawnRate" min="1" max="5" value="3" class="w-full interactive">
            </div>

            <!-- ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ç‡ -->
            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between">
                    <span>ITEM DROP RATE (ã‚¢ã‚¤ãƒ†ãƒ å‡ºç¾ç‡)</span>
                    <span id="dropVal" class="text-white">Normal</span>
                </label>
                <input type="range" id="itemDropRate" min="1" max="5" value="3" class="w-full interactive">
            </div>

            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between">
                    <span>BULLET POWER (å¼¾ã®å¨åŠ›)</span>
                    <span id="powerVal" class="text-white">10</span>
                </label>
                <input type="range" id="bulletPower" min="5" max="50" step="5" value="10" class="w-full interactive">
            </div>

            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between">
                    <span>ENEMY SPEED (æ•µã®é€Ÿåº¦)</span>
                    <span id="speedVal" class="text-white">Normal</span>
                </label>
                <input type="range" id="enemySpeed" min="1" max="10" value="3" class="w-full interactive">
            </div>

            <!-- æ•µHPå€ç‡ (å…±é€š) -->
            <div class="mb-4">
                <label class="block text-xs text-gray-400 mb-1 flex justify-between">
                    <span>ENEMY HP MULTIPLIER (æ•µã®è€ä¹…åŠ›)</span>
                    <span id="enemyHpVal" class="text-white">x1.0</span>
                </label>
                <input type="range" id="enemyHp" min="1" max="10" value="2" class="w-full interactive">
            </div>

            <div class="text-center">
                <button id="resetSettingsBtn" class="reset-btn">RESET TO DEFAULT</button>
            </div>
        </div>

        <button id="startBtn" class="neon-btn interactive">START MISSION</button>
        <p id="highScoreDisplay" class="mt-6 text-gray-500 text-sm">HIGH SCORE: 0</p>
    </div>

<script>
/**
 * IQ99999 ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ã‚ˆã‚‹æœ€é©åŒ–ã•ã‚ŒãŸã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
 */

// --- 1. Sound System ---
class SoundSystem {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3; 
        
        // BGMç”¨ã®ãƒãƒ¼ãƒ‰
        this.bgmGain = this.ctx.createGain();
        this.bgmGain.gain.value = 0.6; // BGMéŸ³é‡UP
        this.bgmGain.connect(this.masterGain);
        
        // ãƒ‡ã‚£ãƒ¬ã‚¤ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆã‚„ã¾ã³ã“ï¼‰
        this.delayNode = this.ctx.createDelay();
        this.delayNode.delayTime.value = 0.3; // 300ms
        this.feedbackGain = this.ctx.createGain();
        this.feedbackGain.gain.value = 0.4; // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é‡
        
        this.delayNode.connect(this.feedbackGain);
        this.feedbackGain.connect(this.delayNode);
        this.delayNode.connect(this.bgmGain);
        this.feedbackGain.connect(this.bgmGain); // ã‚¨ã‚³ãƒ¼ã‚‚å‡ºåŠ›

        this.masterGain.connect(this.ctx.destination);
        
        this.bgmInterval = null;
        this.isPlayingBGM = false;
        this.isBossActive = false; // ãƒœã‚¹æˆ¦ãƒ•ãƒ©ã‚°
        
        // ã‚¹ã‚±ãƒ¼ãƒ«: ãƒ‰ãƒªã‚¢ãƒ³ãƒ¢ãƒ¼ãƒ‰é¢¨ (E F# G A B C# D)
        this.scale = [164.81, 185.00, 196.00, 220.00, 246.94, 277.18, 293.66, 329.63, 392.00, 440.00];
    }

    resume() {
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    startBGM() {
        if (this.isPlayingBGM) return;
        this.isPlayingBGM = true;
        this.resume();
        
        let noteIndex = 0;
        let bassNote = 82.41; // E2

        // ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼
        this.bgmInterval = setInterval(() => {
            if (!this.isPlayingBGM) return;
            const now = this.ctx.currentTime;
            
            // 1. ã‚¢ãƒ«ãƒšã‚¸ã‚ª (ãƒ©ãƒ³ãƒ€ãƒ ãªéŸ³)
            if (Math.random() < 0.7) { // 70%ã®ç¢ºç‡ã§é³´ã‚‰ã™
                const freq = this.scale[Math.floor(Math.random() * this.scale.length)];
                this.playTone(freq, 'sine', 0.1, 0.1, 0.5); // æŸ”ã‚‰ã‹ã„éŸ³
            }

            // 2. ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ (4æ‹ã”ã¨ã«ãƒ«ãƒ¼ãƒˆéŸ³ã‚’å¤‰ãˆã‚‹ãªã©)
            if (noteIndex % 8 === 0) {
                 bassNote = (Math.random() > 0.5) ? 82.41 : 73.42; // E2 or D2
                 this.playTone(bassNote, 'triangle', 0.5, 0.2, 1.5); // é•·ã‚ã®ä½éŸ³
            }

            // 3. ãƒœã‚¹æˆ¦ãƒªã‚ºãƒ  (ãƒ‰ãƒ©ãƒ )
            if (this.isBossActive) {
                // ã‚­ãƒƒã‚¯
                if (noteIndex % 4 === 0) {
                    this.playDrum(150, 0.05, 0.8);
                }
                // ãƒã‚¤ãƒãƒƒãƒˆ (è£æ‹)
                if (noteIndex % 2 === 1) {
                    this.playNoise(0.05, 0.3);
                }
            }
            
            noteIndex++;
        }, 250); // BPM 120ãã‚‰ã„ã®8åˆ†éŸ³ç¬¦
    }

    stopBGM() {
        this.isPlayingBGM = false;
        if (this.bgmInterval) {
            clearInterval(this.bgmInterval);
            this.bgmInterval = null;
        }
        // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯é–‰ã˜ãšã€æ¬¡ã®å†ç”Ÿã«å‚™ãˆã‚‹
        this.isBossActive = false;
    }

    setBossMode(active) {
        this.isBossActive = active;
    }

    // æ±ç”¨ãƒˆãƒ¼ãƒ³å†ç”Ÿãƒ¡ã‚½ãƒƒãƒ‰
    playTone(freq, type, vol, attack, release) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆéŸ³ã®å½¢ï¼‰
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + attack);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + attack + release);
        
        osc.connect(gain);
        gain.connect(this.bgmGain); // BGMãƒã‚¹ã¸
        
        // ã‚¨ã‚³ãƒ¼ã¸ã‚‚é€ã‚‹ (é‡ã‚’èª¿æ•´)
        const sendToDelay = this.ctx.createGain();
        sendToDelay.gain.value = 0.5;
        gain.connect(sendToDelay);
        sendToDelay.connect(this.delayNode);
        
        osc.start();
        osc.stop(this.ctx.currentTime + attack + release);
    }

    playDrum(freq, duration, vol) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.bgmGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playNoise(duration, vol) {
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.value = vol;
        
        // ãƒã‚¤ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã§ã‚·ãƒ£ãƒªã‚·ãƒ£ãƒªæ„Ÿã‚’å‡ºã™
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 5000;

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.bgmGain);
        noise.start();
    }

    playShoot() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        // ä¿®æ­£: å¿ƒåœ°ã‚ˆã„ã‚·ãƒ³ã‚» (Sine + é«˜é€Ÿãƒ”ãƒƒãƒãƒ€ã‚¦ãƒ³)
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
        
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
    }

    playEnemyShoot() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
    }

    playExplosion() {
        // ãƒã‚¤ã‚ºç”Ÿæˆã¯è¤‡é›‘ãªã®ã§ã€ä½å‘¨æ³¢ã®è’ã„æ³¢å½¢ã§ä»£ç”¨
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.4);
        
        // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã§ã“ã‚‚ã‚‰ã›ã‚‹
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500;

        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
    }

    playBossSpawn(isLastBoss = false) {
        // ä¿®æ­£: ç¶ºéº—ãªå’ŒéŸ³ã®ã‚ˆã†ãªéŸ³ (Chord Sweep)
        const freqs = isLastBoss ? [110, 164.8, 196] : [220, 277.2, 330];
        
        freqs.forEach((f, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth'; // å€éŸ³æˆåˆ†
            osc.frequency.setValueAtTime(f, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(f * 0.5, this.ctx.currentTime + 2.0); // ãƒ”ãƒƒãƒãƒ€ã‚¦ãƒ³ã§å¨åœ§æ„Ÿ
            
            // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã§è§’ã‚’å–ã‚‹
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, this.ctx.currentTime);
            filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 2.0);

            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.1);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2.0);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 2.0);
        });
    }

    playItemGet(type) {
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        if (type === 0) { // POWER (Red)
            osc.type = 'square';
            osc.frequency.setValueAtTime(220, now);
            osc.frequency.exponentialRampToValueAtTime(880, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
        } else if (type === 1) { // SPEED (Blue)
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(880, now);
            osc.frequency.exponentialRampToValueAtTime(3520, now + 0.2); 
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.frequency.linearRampToValueAtTime(10000, now + 0.2);
            osc.disconnect();
            osc.connect(filter);
            filter.connect(gain);
        } else { // HEAL (Green)
            this.playTone(523.25, 'sine', 0.3, 0.05, 0.4); 
            setTimeout(() => this.playTone(659.25, 'sine', 0.3, 0.05, 0.4), 50); 
            setTimeout(() => this.playTone(783.99, 'sine', 0.3, 0.05, 0.4), 100); 
            return; 
        }

        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(now + 0.5);
    }
    
    // playPowerUp() { // äº’æ›æ€§ã®ãŸã‚æ®‹ã™ãŒã€åŸºæœ¬ã¯playItemGetã‚’ä½¿ã†
    //    this.playItemGet(0);
    // }
    
    playHeal() {
        this.playItemGet(2);
    }

    playBomb() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 1.5);
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, this.ctx.currentTime);
        filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 1.0);

        gain.gain.setValueAtTime(1.0, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.5);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
    }

    playOverheat() {
        // ä¿®æ­£: ãƒ–ãƒ¼ãƒŸãƒ¼ã§é‡åšãªã€Œã‚·ã‚¹ãƒ†ãƒ ãƒ€ã‚¦ãƒ³ã€éŸ³
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        // é‹¸æ­¯çŠ¶æ³¢ã§å€éŸ³ã‚’å‡ºã—ã€æ©Ÿæ¢°çš„ãªéŸ¿ãã«ã™ã‚‹
        osc.type = 'sawtooth';
        
        // ä½ã„å‘¨æ³¢æ•°ã‹ã‚‰ã•ã‚‰ã«ä½ãè½ã¨ã™ (ãƒ–ã‚¥ã‚¥ãƒ¼ãƒ³...)
        osc.frequency.setValueAtTime(400, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 1.0);
        
        // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ã§é«˜éŸ³ã‚’å‰Šã‚Šã€ã“ã‚‚ã£ãŸéŸ³ã«ã™ã‚‹ (ãƒ–ãƒ¼ãƒŸãƒ¼æ„Ÿ)
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, this.ctx.currentTime);
        filter.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + 1.0);
        filter.Q.value = 5;

        // éŸ³é‡ã¯å°‘ã—å¤§ãã‚ã‹ã‚‰å…¥ã‚Šã€ã‚†ã£ãã‚Šæ¸›è¡°
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.0);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1.0);
    }
    
    playClear() {
        const now = this.ctx.currentTime;
        const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51, 1567.98, 2093.00]; 
        notes.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(freq, now + i * 0.15);
            gain.gain.setValueAtTime(0.3, now + i * 0.15);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 1.5);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start(now + i * 0.15);
            osc.stop(now + i * 0.15 + 1.5);
        });
    }
}

// --- 2. Entities ---

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.color = '#00ffff';
        this.maxHp = 100; // è¿½åŠ : æœ€å¤§HPã‚’ç®¡ç†
        this.hp = this.maxHp;
        this.lastShotTime = 0;
        
        this.shootInterval = 250; 
        
        this.shotLevel = 1; 
        this.bulletSpeed = 12; 
        this.aimAngle = -Math.PI / 2;
        this.bombs = 0; 
        this.power = settings.bulletPower; // è¿½åŠ : ç¾åœ¨ã®æ”»æ’ƒåŠ›

        this.heat = 0;
        this.maxHeat = 100;
        this.overheated = false;
        this.heatPerShot = 10;
        this.coolingRate = 0.8; 
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.aimAngle + Math.PI / 2);

        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        if (this.overheated) {
            ctx.fillStyle = (Date.now() % 200 < 100) ? '#ff3333' : '#550000';
        } else {
            ctx.fillStyle = this.color;
        }
        
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0;

        ctx.beginPath();
        ctx.arc(0, 0, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.closePath();
        
        ctx.beginPath();
        ctx.rect(-2, -this.radius - 5, 4, 10);
        ctx.fillStyle = '#00ffff';
        ctx.fill();
        
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle, speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.radius = 4;
        this.markedForDeletion = false;
        this.color = '#ffff00';
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0;
    }
}

class EnemyBullet {
    constructor(x, y, angle, speed = 6) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.radius = 6;
        this.markedForDeletion = false;
        this.color = '#ff0055'; 
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.shadowBlur = 0;
        
        // Core
        ctx.beginPath();
        ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.closePath();
    }
}

class Enemy {
    constructor(x, y, player, speedMultiplier, playerShotLevel) {
        this.x = x;
        this.y = y;
        this.player = player;
        this.speed = (Math.random() * 2 + 1) * speedMultiplier;
        
        // ä¿®æ­£: æ•µã®æœ€å°ã‚µã‚¤ã‚ºã‚’ 10 -> 15 ã«æ‹¡å¤§
        this.radius = 15 + Math.random() * 15;
        this.originalRadius = this.radius;
        this.sizeFactor = this.radius / 15;
        
        this.markedForDeletion = false;
        
        // --- â˜…â˜…â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: æ•µã®ç¡¬ã•ä¿‚æ•° â˜…â˜…â˜… ---
        // baseHp: åŸºç¤HP (å¤‰æ›´å‰: 4 -> å¤‰æ›´å¾Œ: 10)
        const baseHp = 10; 
        // scalingFactor: å¼¾æ•°ãŒå¢—ãˆã‚‹ã”ã¨ã®HPå¢—åŠ é‡ (å¤‰æ›´å‰: 3 -> å¤‰æ›´å¾Œ: 10)
        const scalingFactor = 10; 
        
        const levelBonus = (playerShotLevel - 1) * scalingFactor;
        this.maxHp = (baseHp + levelBonus) * this.sizeFactor * settings.enemyHpMultiplier;
        this.hp = this.maxHp;

        const hue = Math.random() * 60 + 300; 
        this.color = `hsl(${hue}, 80%, 60%)`;
        this.angle = 0;
    }

    update() {
        const dx = this.player.x - this.x;
        const dy = this.player.y - this.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance > 0) {
            const speedMod = 1 / Math.sqrt(this.sizeFactor);
            this.x += (dx / distance) * this.speed * speedMod;
            this.y += (dy / distance) * this.speed * speedMod;
        }
        this.angle += 0.1;
        
        const hpRatio = Math.max(0, this.hp / this.maxHp);
        this.radius = this.originalRadius * (0.4 + 0.6 * hpRatio);
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        const s = this.radius;
        ctx.rect(-s/2, -s/2, s, s);
        ctx.fillStyle = 'transparent';
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(0, 0, s/3, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

class Boss {
    constructor(x, y, player, spawnCount, isLastBoss = false, hpMultiplier = 1.0) {
        this.x = x;
        this.y = y;
        this.player = player;
        this.spawnCount = spawnCount;
        this.isLastBoss = isLastBoss;
        
        this.lastShotTime = 0;
        this.shootInterval = isLastBoss ? 700 : 1500; 
        
        // --- â˜…â˜…â˜… èª¿æ•´ãƒã‚¤ãƒ³ãƒˆ: ãƒœã‚¹ã®HPè¨­å®š â˜…â˜…â˜… ---
        // HPèª¿æ•´: å¤§å¹…ã«è»ŸåŒ– (1/10) -> åˆæœŸHP 300
        if (isLastBoss) {
            // ãƒ©ã‚¹ãƒœã‚¹: 300,000
            this.maxHp = 300000 * hpMultiplier;
            this.radius = 80;
            this.color = '#ff0000'; 
            this.speed = 1.0; 
        } else {
            // é€šå¸¸ãƒœã‚¹: 5000 + (ã‚¹ãƒãƒ¼ãƒ³ã‚«ã‚¦ãƒ³ãƒˆ * 15000)
            // 1ä½“ç›®(count=1): 20,000
            this.maxHp = (5000 + (spawnCount * 15000)) * hpMultiplier; 
            this.radius = 50;
            this.color = '#ff0055'; 
            this.speed = 1.2;
        }
        // ------------------------------------
        
        this.hp = this.maxHp;
        this.flashTime = 0; // è¿½åŠ : è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ç”¨ã‚¿ã‚¤ãƒãƒ¼
        this.markedForDeletion = false;
        this.angle = 0;
    }

    update(enemyBullets, soundSystem) { 
        const dx = this.player.x - this.x;
        const dy = this.player.y - this.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance > 0) {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
        }
        this.angle += 0.02;

        const now = Date.now();
        if (now - this.lastShotTime > this.shootInterval) {
            
            if (this.isLastBoss) {
                const ways = 12;
                const offset = (this.angle * 2) % (Math.PI * 2); 
                for (let i = 0; i < ways; i++) {
                    const angle = offset + (Math.PI * 2 / ways) * i;
                    enemyBullets.push(new EnemyBullet(this.x, this.y, angle, 5));
                }
            } else {
                const baseAngle = Math.atan2(this.player.y - this.y, this.player.x - this.x);
                enemyBullets.push(new EnemyBullet(this.x, this.y, baseAngle, 7));
                enemyBullets.push(new EnemyBullet(this.x, this.y, baseAngle - 0.2, 7));
                enemyBullets.push(new EnemyBullet(this.x, this.y, baseAngle + 0.2, 7));
            }
            
            soundSystem.playEnemyShoot();
            this.lastShotTime = now;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // ãƒœã‚¹æœ¬ä½“ (ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°)
        const time = Date.now() * 0.003;
        const morph = (Math.sin(time) + 1) / 2; // 0.0 ~ 1.0
        
        ctx.beginPath(); 
        const cornerRadius = this.radius * morph; // è§’ã®ä¸¸ã¿
        const x = -this.radius;
        const y = -this.radius;
        const w = this.radius * 2;
        const h = this.radius * 2;
        const r = cornerRadius;

        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();

        if (this.flashTime > 0) {
            ctx.fillStyle = 'white';
            this.flashTime--;
        } else {
            ctx.fillStyle = this.isLastBoss ? 'rgba(255, 0, 0, 0.3)' : 'rgba(255, 0, 85, 0.2)';
        }
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 4;
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(0, 0, this.isLastBoss ? 30 : 20, 0, Math.PI * 2);
        ctx.fillStyle = this.isLastBoss ? '#ffffff' : '#ffcc00';
        ctx.fill();

        ctx.restore();
        
        // HPãƒãƒ¼
        const barWidth = this.isLastBoss ? 200 : 100;
        const barHeight = 8;
        const hpPercent = this.hp / this.maxHp;
        const yOffset = this.radius + 20;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(this.x - barWidth/2, this.y - yOffset, barWidth, barHeight);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - barWidth/2, this.y - yOffset, barWidth * Math.max(0, hpPercent), barHeight);
        ctx.strokeStyle = '#fff';
        ctx.strokeRect(this.x - barWidth/2, this.y - yOffset, barWidth, barHeight);
        
        // HPæ•°å€¤è¡¨ç¤º
        ctx.fillStyle = '#fff';
        ctx.font = '10px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillText(`HP: ${Math.floor(Math.max(0, this.hp))} / ${Math.floor(this.maxHp)}`, this.x, this.y - yOffset + 20);
        
        if (this.isLastBoss) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText("OMEGA GUARDIAN", this.x, this.y - yOffset - 15);
        }
    }
}

class PowerUp {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.markedForDeletion = false;
        this.angle = 0;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.creationTime = Date.now();
        this.lifeTime = 10000; 
        this.opacity = 1.0;
        
        this.type = 0;
        this.color = '#ffaa00';
        this.label = 'P';
    }

    update(player) {
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
        this.x += this.vx;
        this.y += this.vy;

        const age = Date.now() - this.creationTime;
        
        const cycle = Math.floor(age / 1000) % 3;
        this.type = cycle;
        if (this.type === 0) {
            this.color = '#ffaa00'; 
            this.label = 'P';
        } else if (this.type === 1) {
            this.color = '#00ffff'; 
            this.label = 'S';
        } else {
            this.color = '#00ff00'; 
            this.label = 'H';
        }

        if (age > this.lifeTime) {
            this.markedForDeletion = true;
        } else if (age > this.lifeTime - 1500) {
            this.opacity = Math.abs(Math.sin(age * 0.01)) * 0.8 + 0.2;
        }

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 150) {
            this.x += dx * 0.03;
            this.y += dy * 0.03;
        }
        this.angle += 0.05;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.globalAlpha = this.opacity;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const theta = (i * Math.PI * 2) / 6;
            const px = Math.cos(theta) * this.radius;
            const py = Math.sin(theta) * this.radius;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 0;
        ctx.fillText(this.label, 0, 0);
        ctx.restore();
    }
}

class BombItem {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.color = '#ff0000'; 
        this.markedForDeletion = false;
        this.angle = 0;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.creationTime = Date.now();
        this.lifeTime = 15000; 
        this.opacity = 1.0;
    }

    update(player) {
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
        this.x += this.vx;
        this.y += this.vy;

        const age = Date.now() - this.creationTime;
        if (age > this.lifeTime) {
            this.markedForDeletion = true;
        } else if (age > this.lifeTime - 1500) {
            this.opacity = Math.abs(Math.sin(age * 0.01)) * 0.8 + 0.2;
        }

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 150) {
            this.x += dx * 0.03;
            this.y += dy * 0.03;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.globalAlpha = this.opacity;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Orbitron';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = 0;
        ctx.fillText('B', 0, 0);
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3 + 1;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.alpha = 1;
        this.color = color;
        this.markedForDeletion = false;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= this.decay;
        this.radius *= 0.95;
        if (this.alpha <= 0 || this.radius < 0.1) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.restore();
    }
}

class Star {
    constructor(w, h) {
        this.reset(w, h);
        this.z = Math.random() * w;
    }

    reset(w, h) {
        this.x = (Math.random() - 0.5) * w * 2;
        this.y = (Math.random() - 0.5) * h * 2;
        this.z = w;
    }

    update(w, h, speed) {
        this.z -= speed;
        if (this.z <= 0) {
            this.reset(w, h);
        }
    }

    draw(ctx, w, h) {
        const sx = (this.x / this.z) * w + w/2;
        const sy = (this.y / this.z) * h + h/2;
        const r = (1 - this.z / w) * 3;
        if (sx > 0 && sx < w && sy > 0 && sy < h) {
            ctx.beginPath();
            ctx.arc(sx, sy, r, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${1 - this.z/w})`;
            ctx.fill();
        }
    }
}

// --- 3. Main Game Engine ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('scoreDisplay');
const hpEl = document.getElementById('hpDisplay');
const timeEl = document.getElementById('timeDisplay');
const bombEl = document.getElementById('bombDisplay');
const bombKeyInfo = document.getElementById('bombKeyInfo');
const heatBar = document.getElementById('heatBar'); 
const heatLabel = document.getElementById('heatLabel'); 
const menuLayer = document.getElementById('menuLayer');
const startBtn = document.getElementById('startBtn');
const highScoreDisplay = document.getElementById('highScoreDisplay');
const warningLayer = document.getElementById('warningLayer');
const warningTitle = document.getElementById('warningTitle');
const warningSubtitle = document.getElementById('warningSubtitle');
const flashLayer = document.getElementById('flashLayer');
const storyModal = document.getElementById('storyModal'); 
const storyToggle = document.getElementById('storyToggle'); 
const closeStoryBtn = document.getElementById('closeStoryBtn'); 

// Stat Elements
const statAtk = document.getElementById('statAtk');
const statSpd = document.getElementById('statSpd');
const statShot = document.getElementById('statShot');

// Mobile UI Elements
const mobileControls = document.getElementById('mobileControls');
const joystickZone = document.getElementById('joystickZone');
const joystickKnob = document.getElementById('joystickKnob');
const shootBtn = document.getElementById('shootBtn');
const mobileBombBtn = document.getElementById('mobileBombBtn');

// Settings Elements
const settingsToggle = document.getElementById('settingsToggle');
const settingsPanel = document.getElementById('settingsPanel');
const resetSettingsBtn = document.getElementById('resetSettingsBtn');
const spawnRateInput = document.getElementById('spawnRate');
const bulletPowerInput = document.getElementById('bulletPower');
const enemySpeedInput = document.getElementById('enemySpeed');
const itemDropRateInput = document.getElementById('itemDropRate');
const enemyHpInput = document.getElementById('enemyHp');
const autoAimToggle = document.getElementById('autoAimToggle');

// åˆæœŸè¨­å®šå€¤
const defaultSettings = {
    spawnRate: 3, 
    bulletPower: 10,
    enemySpeedMultiplier: 1.0, 
    itemDropRate: 0.18, // Normal (18%)
    enemyHpMultiplier: 1.0, 
    autoAim: true // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆON
};

let settings = { ...defaultSettings };

let gameActive = false;
let score = 0;
let highScore = 0;
let frameCount = 0;
let mouseX = 0;
let mouseY = 0;
let isMouseDown = false;
let gameStartTime = 0;
const TIME_LIMIT = 10 * 60 * 1000; 
let isMobile = false; 

// Boss Logic Variables
const BOSS_INTERVAL = 2 * 60 * 1000; 
let nextBossTime = BOSS_INTERVAL;
let bossSpawnCount = 0;
let lastBossSpawned = false; 

// Mobile Input State
let joystick = { x: 0, y: 0, active: false, id: null, startX: 0, startY: 0 };
let mobileShootActive = false;
let canvasScale = 1; 

let player;
let bullets = [];
let enemyBullets = []; 
let enemies = [];
let bosses = []; 
let particles = [];
let stars = [];
let powerUps = []; 
let bombItems = []; 
const soundSystem = new SoundSystem();

function resize() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    checkDevice();

    if (isMobile) {
        const minSide = Math.min(width, height);
        const targetMinSide = 600; 
        canvasScale = Math.max(1, targetMinSide / minSide);
    } else {
        canvasScale = 1;
    }

    canvas.width = width * canvasScale;
    canvas.height = height * canvasScale;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    if (player) {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
    }
}
window.addEventListener('resize', resize);

for (let i = 0; i < 100; i++) {
    stars.push(new Star(canvas.width, canvas.height));
}

function checkDevice() {
    isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const pcGuide = document.getElementById('pcGuide');
    const mobileGuide = document.getElementById('mobileGuide');
    
    if (typeof settings.autoAim === 'undefined') {
        settings.autoAim = true;
        autoAimToggle.checked = settings.autoAim;
    }

    if (isMobile) {
        pcGuide.style.display = 'none';
        mobileGuide.style.display = 'block';
        bombKeyInfo.innerText = '(Tap Button)';
        mobileControls.style.display = 'block';
    } else {
        pcGuide.style.display = 'block';
        mobileGuide.style.display = 'none';
        bombKeyInfo.innerText = '(Right Click)';
        mobileControls.style.display = 'none';
    }
}
checkDevice();
resize(); 

// PC Mouse Controls
window.addEventListener('mousemove', (e) => { 
    if (!isMobile) {
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouseX = Math.max(0, Math.min(canvas.width, clientX));
        mouseY = Math.max(0, Math.min(canvas.height, clientY));
    }
});
window.addEventListener('mousedown', (e) => {
    if (!isMobile && e.button === 0) isMouseDown = true; 
});
window.addEventListener('mouseup', () => {
    if (!isMobile) isMouseDown = false;
});
window.addEventListener('contextmenu', (e) => {
    if (!isMobile) {
        e.preventDefault();
        useBomb();
        return false;
    }
});

// Mobile Controls
joystickZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    joystick.id = touch.identifier;
    joystick.active = true;
    joystick.startX = touch.clientX;
    joystick.startY = touch.clientY;
    updateJoystickVisual(0, 0);
}, {passive: false});

joystickZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!joystick.active) return;
    
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === joystick.id) {
            const touch = e.changedTouches[i];
            const maxDist = 40; 
            let dx = touch.clientX - joystick.startX;
            let dy = touch.clientY - joystick.startY;
            const dist = Math.hypot(dx, dy);
            
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            joystick.x = dx / maxDist;
            joystick.y = dy / maxDist;
            
            updateJoystickVisual(dx, dy);
            break;
        }
    }
}, {passive: false});

const endJoystick = (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === joystick.id) {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            updateJoystickVisual(0, 0);
            break;
        }
    }
};
joystickZone.addEventListener('touchend', endJoystick);
joystickZone.addEventListener('touchcancel', endJoystick);

function updateJoystickVisual(x, y) {
    joystickKnob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
}

shootBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    mobileShootActive = true;
    shootBtn.classList.add('active');
}, {passive: false});

shootBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    mobileShootActive = false;
    shootBtn.classList.remove('active');
}, {passive: false});

mobileBombBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    useBomb();
    mobileBombBtn.style.transform = 'scale(0.9)';
    setTimeout(() => mobileBombBtn.style.transform = 'scale(1)', 100);
}, {passive: false});


// UI Logic
storyToggle.addEventListener('click', () => { storyModal.style.display = 'flex'; });
closeStoryBtn.addEventListener('click', () => { storyModal.style.display = 'none'; });
settingsToggle.addEventListener('click', () => {
    if (settingsPanel.classList.contains('hidden')) {
        settingsPanel.classList.remove('hidden');
        settingsToggle.innerText = 'SETTINGS â–²';
    } else {
        settingsPanel.classList.add('hidden');
        settingsToggle.innerText = 'SETTINGS â–¼';
    }
});

// Settings Handlers
function updateUIFromSettings() {
    spawnRateInput.value = settings.spawnRate;
    document.getElementById('spawnVal').textContent = ["Very Slow", "Slow", "Normal", "Fast", "Chaos"][settings.spawnRate-1];
    
    bulletPowerInput.value = settings.bulletPower;
    document.getElementById('powerVal').textContent = settings.bulletPower;
    
    // ä¿®æ­£: å†…éƒ¨å€¤ 1.0 ã®ã¨ãã€(1.0 - 0.4) / 0.2 = 3.0 ã¨ãªã‚‹ãŸã‚ã€é…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç”¨ã« -1 ã™ã‚‹
    // ã“ã‚Œã«ã‚ˆã‚Š Index 2 (Normal) ã¨ãªã‚Šã€ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å€¤ã¯ 3 ã¨ãªã‚‹
    const speedIndex = Math.round((settings.enemySpeedMultiplier - 0.4) / 0.2) - 1;
    enemySpeedInput.value = speedIndex + 1;
    document.getElementById('speedVal').textContent = ["Crawler", "Slow", "Normal", "Fast", "Blitz", "Sonic", "Hyper", "Mach", "Light", "Warp"][speedIndex] || (speedIndex + 1);
    
    const rateIndex = [0.05, 0.10, 0.18, 0.30, 0.50].indexOf(settings.itemDropRate);
    itemDropRateInput.value = rateIndex !== -1 ? rateIndex + 1 : 3;
    document.getElementById('dropVal').textContent = ["Very Low", "Low", "Normal", "High", "Abundance"][rateIndex !== -1 ? rateIndex : 2];

    enemyHpInput.value = Math.round(settings.enemyHpMultiplier * 2); 
    document.getElementById('enemyHpVal').textContent = `x${settings.enemyHpMultiplier}`;
    
    autoAimToggle.checked = settings.autoAim;
}

spawnRateInput.addEventListener('input', (e) => {
    settings.spawnRate = parseInt(e.target.value);
    updateUIFromSettings();
});
bulletPowerInput.addEventListener('input', (e) => {
    settings.bulletPower = parseInt(e.target.value);
    updateUIFromSettings();
});
enemySpeedInput.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    settings.enemySpeedMultiplier = val * 0.2 + 0.4; 
    updateUIFromSettings();
});
itemDropRateInput.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    const rates = [0.05, 0.10, 0.18, 0.30, 0.50]; // ç¢ºç‡ã‚¢ãƒƒãƒ— (Normal=18%)
    settings.itemDropRate = rates[val-1];
    updateUIFromSettings();
});
enemyHpInput.addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    settings.enemyHpMultiplier = val * 0.5; 
    updateUIFromSettings();
});
autoAimToggle.addEventListener('change', (e) => {
    settings.autoAim = e.target.checked;
});

resetSettingsBtn.addEventListener('click', () => {
    settings = { ...defaultSettings };
    settings.autoAim = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆON
    updateUIFromSettings();
});

// Initialize Settings UI
updateUIFromSettings();


function updateMousePos(e) {
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    mouseX = Math.max(0, Math.min(canvas.width, clientX * canvasScale));
    
    let offsetY = 0;
    if (isMobile && e.touches) {
        offsetY = -50 * canvasScale; 
    }
    mouseY = Math.max(0, Math.min(canvas.height, (clientY * canvasScale) + offsetY));
}

function initGame() {
    score = 0;
    scoreEl.innerText = score;
    hpEl.innerText = 100;
    hpEl.className = "text-xl md:text-2xl text-cyan-400";
    timeEl.innerText = "10:00";
    timeEl.style.color = "#fbbf24"; 
    
    resize();
    
    // å†ãƒ—ãƒ¬ã‚¤æ™‚ã®éŸ³ãƒã‚°å¯¾ç­–
    soundSystem.stopBGM(); 
    
    player = new Player(canvas.width / 2, canvas.height / 2);
    bombEl.innerText = player.bombs;
    updateHeatUI(); 
    updateStatsUI();
    
    // BGMã‚¹ã‚¿ãƒ¼ãƒˆ (å†ç”Ÿå¯èƒ½ãªå ´åˆ)
    soundSystem.startBGM();

    bullets = [];
    enemyBullets = []; 
    enemies = [];
    bosses = [];
    particles = [];
    powerUps = []; 
    bombItems = []; 
    frameCount = 0;
    gameStartTime = Date.now();
    nextBossTime = BOSS_INTERVAL;
    bossSpawnCount = 0;
    lastBossSpawned = false;
    
    gameActive = true;
    menuLayer.style.opacity = '0';
    setTimeout(() => { if(gameActive) menuLayer.style.display = 'none'; }, 300);

    soundSystem.resume();
    loop();
}

// ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡ºã®ãŸã‚ã®é–¢æ•°
function triggerHudFlash(id, color) {
    const el = document.getElementById(id);
    if (!el) return;
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ãƒˆãƒªã‚¬ãƒ¼ã®ãŸã‚ã®ãƒªã‚»ãƒƒãƒˆ
    el.style.animation = 'none';
    el.offsetHeight; /* trigger reflow */
    
    // ã‚¹ã‚¿ã‚¤ãƒ«é©ç”¨
    el.style.color = color;
    el.style.textShadow = `0 0 20px ${color}, 0 0 40px white`;
    el.style.animation = 'hudFlashAnim 0.5s ease-out';
    
    // æˆ»ã™
    setTimeout(() => {
        el.style.color = '';
        el.style.textShadow = '';
    }, 500);
}

function useBomb() {
    if (!gameActive || player.bombs <= 0) return;
    
    player.bombs--;
    bombEl.innerText = player.bombs;
    triggerHudFlash('bombDisplay', '#ff0000'); // ãƒœãƒ æ¶ˆè²»æ™‚ã‚‚å…‰ã‚‰ã›ã‚‹

    soundSystem.playBomb();
    
    flashLayer.style.opacity = '0.8';
    setTimeout(() => flashLayer.style.opacity = '0', 100);
    
    enemies.forEach(e => {
        e.markedForDeletion = true;
        for (let i = 0; i < 5; i++) particles.push(new Particle(e.x, e.y, e.color));
        score += 100;
    });
    
    enemyBullets.forEach(b => {
        b.markedForDeletion = true;
        particles.push(new Particle(b.x, b.y, b.color));
    });
    
    bosses.forEach(b => {
        // ãƒœãƒ ãƒ€ãƒ¡ãƒ¼ã‚¸èª¿æ•´: ç¾åœ¨HPã®20% + å›ºå®š50
        const damage = (b.hp * 0.2) + 50;
        b.hp -= damage;
        showFloatingText(b.x, b.y, "BOMB HIT!", "#ff0000");
        
        // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥è¨­å®š
        b.flashTime = 5;

        if (b.hp <= 0) {
            b.markedForDeletion = true;
            score += 5000 * b.spawnCount;
            soundSystem.playExplosion();
            for (let i = 0; i < 50; i++) particles.push(new Particle(b.x, b.y, b.color));
            
            soundSystem.setBossMode(false); // ãƒªã‚ºãƒ OFF

            if (b.isLastBoss) {
                score += 50000;
                gameClear();
            } else {
                bombItems.push(new BombItem(b.x, b.y));
            }
        }
    });
    
    scoreEl.innerText = score;
    // showFloatingText(player.x, player.y, "BOMB ACTIVATED!", "#ffaa00"); // å‰Šé™¤
}

function spawnEnemy() {
    const edge = Math.floor(Math.random() * 4); 
    let x, y;
    const buffer = 30;
    switch(edge) {
        case 0: x = Math.random() * canvas.width; y = -buffer; break;
        case 1: x = canvas.width + buffer; y = Math.random() * canvas.height; break;
        case 2: x = Math.random() * canvas.width; y = canvas.height + buffer; break;
        case 3: x = -buffer; y = Math.random() * canvas.height; break;
    }
    
    enemies.push(new Enemy(x, y, player, settings.enemySpeedMultiplier, player.shotLevel));
}

function spawnBoss(isLastBoss = false) {
    if (!isLastBoss) bossSpawnCount++;
    const edge = Math.floor(Math.random() * 4); 
    let x, y;
    const buffer = 80;
    switch(edge) {
        case 0: x = canvas.width/2; y = -buffer; break;
        case 1: x = canvas.width + buffer; y = canvas.height/2; break;
        case 2: x = canvas.width/2; y = canvas.height + buffer; break;
        case 3: x = -buffer; y = canvas.height/2; break;
    }
    bosses.push(new Boss(x, y, player, bossSpawnCount, isLastBoss, settings.enemyHpMultiplier));
    soundSystem.setBossMode(true); // ãƒªã‚ºãƒ ON
    if (isLastBoss) {
        warningTitle.innerText = "FINAL WARNING"; warningTitle.style.color = "#ff0000"; warningSubtitle.innerText = "OMEGA GUARDIAN APPROACHING"; soundSystem.playBossSpawn(true);
    } else {
        warningTitle.innerText = "WARNING"; warningTitle.style.color = "#ff0055"; warningSubtitle.innerText = "GIANT ENEMY DETECTED"; soundSystem.playBossSpawn(false);
    }
    warningLayer.style.display = 'block';
    setTimeout(() => { warningLayer.style.display = 'none'; }, 4000);
}

function checkCollisions() {
    bullets.forEach(bullet => {
        enemies.forEach(enemy => {
            if (bullet.markedForDeletion || enemy.markedForDeletion) return;
            const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
            if (dist - enemy.radius - bullet.radius < 1) {
                bullet.markedForDeletion = true;
                // æ”»æ’ƒåŠ›è¨ˆç®—å¤‰æ›´: player.power ã‚’ä½¿ç”¨
                enemy.hp -= player.power;
                particles.push(new Particle(enemy.x, enemy.y, '#ffffff'));
                if (enemy.hp <= 0) {
                    enemy.markedForDeletion = true; 
                    if (Math.random() < settings.itemDropRate) powerUps.push(new PowerUp(enemy.x, enemy.y));
                    for (let i = 0; i < 8; i++) particles.push(new Particle(enemy.x, enemy.y, enemy.color));
                    score += 100; scoreEl.innerText = score; soundSystem.playExplosion();
                }
            }
        });
        bosses.forEach(boss => {
            if (bullet.markedForDeletion || boss.markedForDeletion) return;
            const dist = Math.hypot(bullet.x - boss.x, bullet.y - boss.y);
            if (dist - boss.radius - bullet.radius < 1) {
                bullet.markedForDeletion = true;
                // æ”»æ’ƒåŠ›è¨ˆç®—å¤‰æ›´: player.power ã‚’ä½¿ç”¨
                boss.hp -= player.power;
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥å‡¦ç†
                boss.flashTime = 3;

                particles.push(new Particle(bullet.x, bullet.y, '#ffaa00'));
                if (boss.hp <= 0) {
                    boss.markedForDeletion = true; soundSystem.playExplosion();
                    soundSystem.setBossMode(false); // ãƒªã‚ºãƒ OFF
                    for (let i = 0; i < 50; i++) particles.push(new Particle(boss.x, boss.y, boss.color));
                    if (boss.isLastBoss) { score += 50000; scoreEl.innerText = score; gameClear(); }
                    else { score += 5000 * boss.spawnCount; scoreEl.innerText = score; bombItems.push(new BombItem(boss.x, boss.y)); }
                }
            }
        });
    });

    enemies.forEach(enemy => {
        if (enemy.markedForDeletion) return;
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist - enemy.radius - player.radius < 1) {
            enemy.markedForDeletion = true; player.hp -= 20; updateHpUI(); soundSystem.playExplosion(); screenShake();
            if (player.hp <= 0) gameOver();
        }
    });
    
    bosses.forEach(boss => {
        if (boss.markedForDeletion) return;
        const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
        if (dist - boss.radius - player.radius < 1) {
            player.hp -= 50; updateHpUI(); soundSystem.playExplosion(); screenShake();
            const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
            player.x += Math.cos(angle) * 50; player.y += Math.sin(angle) * 50;
            if (player.hp <= 0) gameOver();
        }
    });

    enemyBullets.forEach(eb => {
        if (eb.markedForDeletion) return;
        const dist = Math.hypot(player.x - eb.x, player.y - eb.y);
        if (dist - eb.radius - player.radius < 1) {
            eb.markedForDeletion = true; player.hp -= 15; updateHpUI(); soundSystem.playExplosion(); 
            for (let i = 0; i < 5; i++) particles.push(new Particle(player.x, player.y, '#ff0000'));
            if (player.hp <= 0) gameOver();
        }
    });

    powerUps.forEach(pu => {
        const dist = Math.hypot(player.x - pu.x, player.y - pu.y);
        if (dist - pu.radius - player.radius < 5) {
            pu.markedForDeletion = true;
            if (pu.type === 0) { 
                player.shotLevel++; 
                player.power += 2; 
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º: ATK, SHOT (Orange)
                triggerHudFlash('statAtk', '#ffaa00');
                triggerHudFlash('statShot', '#ffaa00');
                soundSystem.playItemGet(0);
            }
            else if (pu.type === 1) { 
                player.bulletSpeed = Math.min(25, player.bulletSpeed + 2); 
                // å¤‰æ›´: ç™ºç†±é‡ã‚‚æ¸›ã‚‰ã™ (é€£å°„ã—ã¦ã‚‚ã‚ªãƒ¼ãƒãƒ¼ãƒ’ãƒ¼ãƒˆã—ã«ããã™ã‚‹)
                player.heatPerShot = Math.max(2, player.heatPerShot * 0.9);
                
                player.shootInterval = Math.max(50, player.shootInterval * 0.9); 
                player.power += 4; 
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º: SPD, ATK (Cyan)
                triggerHudFlash('statSpd', '#00ffff');
                triggerHudFlash('statAtk', '#00ffff');
                soundSystem.playItemGet(1);
            }
            else if (pu.type === 2) { 
                player.heat *= 0.5;
                if (player.hp >= player.maxHp) {
                    player.maxHp += 5;
                    player.hp = player.maxHp; 
                    // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º: HP (Green) + ãƒ†ã‚­ã‚¹ãƒˆã‚‚å°‘ã—å‡ºã™? ã„ã‚‰ãªã„ã‹
                } else {
                    player.hp = Math.min(player.maxHp, player.hp + 30);
                }
                // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º: HP (Green)
                triggerHudFlash('hpDisplay', '#00ff00');
                
                updateHpUI();
                soundSystem.playItemGet(2);
            }
            updateStatsUI(); // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        }
    });

    bombItems.forEach(bi => {
        const dist = Math.hypot(player.x - bi.x, player.y - bi.y);
        if (dist - bi.radius - player.radius < 5) {
            bi.markedForDeletion = true; player.bombs++; bombEl.innerText = player.bombs; 
            // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¼”å‡º: BOMB (Red)
            triggerHudFlash('bombDisplay', '#ff0000');
            soundSystem.playItemGet(0);
        }
    });
}

function updateStatsUI() {
    statAtk.innerText = player.power;
    statSpd.innerText = player.bulletSpeed;
    statShot.innerText = player.shotLevel;
}

function updateHpUI() {
    hpEl.innerText = Math.max(0, Math.floor(player.hp));
    if (player.hp <= player.maxHp * 0.3) hpEl.className = "text-xl md:text-2xl text-red-500 animate-pulse";
    else hpEl.className = "text-xl md:text-2xl text-red-400";
}

function updateHeatUI() {
    if (!player) return;
    const percent = Math.min(100, Math.max(0, (player.heat / player.maxHeat) * 100));
    heatBar.style.width = `${percent}%`;
    
    if (player.overheated) {
        heatBar.style.backgroundColor = '#ef4444'; 
        heatBar.parentElement.classList.add('border-red-500');
        heatLabel.innerText = "OVERHEAT!";
        heatLabel.classList.add('text-red-500', 'animate-pulse');
    } else {
        if (percent > 80) heatBar.style.backgroundColor = '#f97316'; 
        else heatBar.style.backgroundColor = '#eab308'; 
        
        heatBar.parentElement.classList.remove('border-red-500');
        heatLabel.innerText = "HEAT";
        heatLabel.classList.remove('text-red-500', 'animate-pulse');
        heatLabel.className = "text-xs text-orange-400 mt-1";
    }
}

function screenShake() {
    canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
    setTimeout(() => canvas.style.transform = 'translate(0,0)', 50);
}

function showFloatingText(x, y, text, color = '#00ff00') {
    const floatText = document.createElement('div');
    floatText.innerText = text; floatText.style.position = 'absolute'; floatText.style.left = `${x}px`; 
    // â˜…ä¿®æ­£: è‡ªæ©Ÿã®ä¸‹å´ã«å‡ºã™ (+30px)
    floatText.style.top = `${y + 30}px`; 
    floatText.style.color = color; floatText.style.fontWeight = 'bold'; 
    floatText.style.fontSize = '12px'; // å°‘ã—å°ã•ã‚ã«
    floatText.style.pointerEvents = 'none'; 
    floatText.style.whiteSpace = 'nowrap'; // æ”¹è¡Œã•ã›ãªã„
    floatText.style.transform = 'translateX(-50%)'; // ä¸­å¤®æƒãˆè£œæ­£
    // â˜…ä¿®æ­£: ãƒ¯ã‚¤ãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨
    floatText.style.animation = 'wipeAnim 0.8s forwards';
    
    document.body.appendChild(floatText); setTimeout(() => floatText.remove(), 800);
}

function gameClear() {
    gameActive = false; soundSystem.playClear(); soundSystem.stopBGM();
    if (score > highScore) { highScore = score; highScoreDisplay.innerText = `HIGH SCORE: ${highScore}`; localStorage.setItem('neon_guardian_highscore', highScore); }
    menuLayer.style.display = 'flex'; setTimeout(() => menuLayer.style.opacity = '1', 10);
    document.querySelector('#menuLayer h1').innerText = "MISSION CLEAR"; document.querySelector('#menuLayer h1').className = "text-4xl md:text-6xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-600"; document.querySelector('#startBtn').innerText = "PLAY AGAIN";
}

function gameOver() {
    gameActive = false; soundSystem.stopBGM();
    if (score > highScore) { highScore = score; highScoreDisplay.innerText = `HIGH SCORE: ${highScore}`; localStorage.setItem('neon_guardian_highscore', highScore); }
    menuLayer.style.display = 'flex'; setTimeout(() => menuLayer.style.opacity = '1', 10);
    document.querySelector('#menuLayer h1').innerText = "GAME OVER"; document.querySelector('#menuLayer h1').className = "text-4xl md:text-6xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-red-500 to-pink-600"; document.querySelector('#startBtn').innerText = "RETRY MISSION";
}

function formatTime(ms) {
    const totalSeconds = Math.max(0, Math.floor(ms / 1000));
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function loop() {
    if (!gameActive) return;
    requestAnimationFrame(loop);
    frameCount++;

    const elapsed = Date.now() - gameStartTime;
    let remaining = TIME_LIMIT - elapsed;
    
    if (remaining <= 0) {
        if (!lastBossSpawned) { spawnBoss(true); lastBossSpawned = true; }
        timeEl.innerText = "FINAL BATTLE"; timeEl.style.color = "red";
    } else {
        timeEl.innerText = formatTime(remaining);
        if (elapsed >= nextBossTime) { spawnBoss(false); nextBossTime += BOSS_INTERVAL; }
    }

    ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    stars.forEach(star => { star.update(canvas.width, canvas.height, 10); star.draw(ctx, canvas.width, canvas.height); });

    // Player Movement
    if (isMobile) {
        if (joystick.active) {
            const speed = 5 * canvasScale; 
            player.x += joystick.x * speed; player.y += joystick.y * speed;
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
        }

        let nearestTarget = null;
        let minDist = Infinity;
        if (settings.autoAim) {
            [...enemies, ...bosses].forEach(target => {
                if (target.markedForDeletion) return;
                const dist = Math.hypot(target.x - player.x, target.y - player.y);
                if (dist < minDist) { minDist = dist; nearestTarget = target; }
            });
            if (nearestTarget) player.aimAngle = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x);
            else if (joystick.active && (joystick.x !== 0 || joystick.y !== 0)) player.aimAngle = Math.atan2(joystick.y, joystick.x);
        } else {
            if (joystick.active && (joystick.x !== 0 || joystick.y !== 0)) player.aimAngle = Math.atan2(joystick.y, joystick.x);
        }
    } else {
        if (mouseX !== 0 && mouseY !== 0) {
            player.x += (mouseX - player.x) * 0.15; player.y += (mouseY - player.y) * 0.15;
            const dx = mouseX - player.x; const dy = mouseY - player.y;
            if (settings.autoAim) {
                let nearestTarget = null; let minDist = Infinity;
                [...enemies, ...bosses].forEach(target => {
                    if (target.markedForDeletion) return;
                    const dist = Math.hypot(target.x - player.x, target.y - player.y);
                    if (dist < minDist) { minDist = dist; nearestTarget = target; }
                });
                if (nearestTarget) player.aimAngle = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x);
                else player.aimAngle = Math.atan2(dy, dx);
            } else {
                if (Math.hypot(dx, dy) > 10) player.aimAngle = Math.atan2(dy, dx);
            }
        }
    }
    player.draw(ctx);

    if (!player.overheated) {
        if (!(isMobile ? mobileShootActive : isMouseDown)) player.heat = Math.max(0, player.heat - player.coolingRate);
    } else {
        player.heat = Math.max(0, player.heat - player.coolingRate);
        if (player.heat <= 0) player.overheated = false;
    }
    updateHeatUI();

    const shooting = (isMobile ? mobileShootActive : isMouseDown) && !player.overheated;
    
    if (shooting) {
        const now = Date.now();
        if (now - player.lastShotTime > player.shootInterval) {
            player.heat += player.heatPerShot;
            if (player.heat >= player.maxHeat) { player.heat = player.maxHeat; player.overheated = true; soundSystem.playOverheat(); }
            const baseAngle = player.aimAngle;
            const count = player.shotLevel;
            const spread = 0.15; 
            const startAngle = baseAngle - ((count - 1) * spread) / 2;
            for (let i = 0; i < count; i++) {
                const angle = startAngle + (i * spread);
                bullets.push(new Bullet(player.x, player.y, angle, player.bulletSpeed));
            }
            soundSystem.playShoot();
            player.lastShotTime = now;
        }
    }

    const difficultyMultiplier = 1 + (elapsed / 60000) * 0.5; 
    let baseInterval = 150 - (settings.spawnRate * 20); 
    let actualInterval = baseInterval / difficultyMultiplier;
    actualInterval = Math.max(5, actualInterval);

    if (frameCount % Math.floor(actualInterval) === 0) spawnEnemy();

    particles.forEach((p, index) => { p.update(); p.draw(ctx); if (p.markedForDeletion) particles.splice(index, 1); });
    bullets.forEach((b, index) => { b.update(); b.draw(ctx); if (b.markedForDeletion) bullets.splice(index, 1); });
    enemyBullets.forEach((eb, index) => { eb.update(); eb.draw(ctx); if (eb.markedForDeletion) enemyBullets.splice(index, 1); });
    enemies.forEach((e, index) => { e.update(); e.draw(ctx); if (e.markedForDeletion) enemies.splice(index, 1); });
    bosses.forEach((b, index) => { b.update(enemyBullets, soundSystem); b.draw(ctx); if (b.markedForDeletion) bosses.splice(index, 1); });
    powerUps.forEach((p, index) => { p.update(player); p.draw(ctx); if (p.markedForDeletion) powerUps.splice(index, 1); });
    bombItems.forEach((b, index) => { b.update(player); b.draw(ctx); if (b.markedForDeletion) bombItems.splice(index, 1); });

    checkCollisions();
}

const savedScore = localStorage.getItem('neon_guardian_highscore');
if (savedScore) {
    highScore = parseInt(savedScore);
    highScoreDisplay.innerText = `HIGH SCORE: ${highScore}`;
}

startBtn.addEventListener('click', () => { initGame(); });
mouseX = canvas.width / 2;
mouseY = canvas.height / 2;

</script>
</body>
</html>
